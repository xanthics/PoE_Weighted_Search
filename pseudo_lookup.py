#!/usr/bin/python
# -*- coding: utf-8 -*-
# Generated: 10/25/2021(m/d/y) 07:16:31 utc


# Autogenerated function to implement pseudomods
def pseudo_lookup(modstr, base, reverse, selections):
	ret = {}
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Global Critical Strike Chance"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_global_critical_strike_chance"] = [round(modstr["#% increased Global Critical Strike Chance"][0], 2), modstr["#% increased Global Critical Strike Chance"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Global Critical Strike Chance"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_global_critical_strike_chance"] = "+#% Global Critical Strike Chance"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Critical Strike Chance for Spells"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_critical_strike_chance_for_spells"] = [round(modstr["#% increased Critical Strike Chance for Spells"][0], 2), modstr["#% increased Critical Strike Chance for Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Critical Strike Chance for Spells"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_critical_strike_chance_for_spells"] = "+#% total Critical Strike Chance for Spells"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% to Global Critical Strike Multiplier"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_global_critical_strike_multiplier"] = [round(modstr["#% to Global Critical Strike Multiplier"][0], 2), modstr["#% to Global Critical Strike Multiplier"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% to Global Critical Strike Multiplier"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_global_critical_strike_multiplier"] = "+#% Global Critical Strike Multiplier"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Cast Speed"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_total_cast_speed"] = [round(modstr["#% increased Cast Speed"][0], 2), modstr["#% increased Cast Speed"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Cast Speed"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_total_cast_speed"] = "+#% total Cast Speed"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["Adds # to # Chaos Damage to Attacks"][0] and (modstr["Adds # to # Chaos Damage to Attacks"][0] == modstr["Adds # to # Chaos Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_chaos_damage_to_attacks"] = [round(modstr["Adds # to # Chaos Damage to Attacks"][0], 2), modstr["Adds # to # Chaos Damage to Attacks"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Chaos Damage to Attacks"][0] = modstr["Adds # to # Chaos Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_chaos_damage_to_attacks"] = "Adds # to # Chaos Damage to Attacks"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Chaos Damage to Spells"][0] and (modstr["Adds # to # Chaos Damage to Spells"][0] == modstr["Adds # to # Chaos Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_chaos_damage_to_spells"] = [round(modstr["Adds # to # Chaos Damage to Spells"][0], 2), modstr["Adds # to # Chaos Damage to Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Chaos Damage to Spells"][0] = modstr["Adds # to # Chaos Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_chaos_damage_to_spells"] = "Adds # to # Chaos Damage to Spells"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Chaos Damage"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_chaos_damage"] = [round(modstr["Adds # to # Chaos Damage"][0], 2), modstr["Adds # to # Chaos Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Chaos Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_chaos_damage"] = "Adds # to # Chaos Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["Adds # to # Lightning Damage to Attacks"][0] and (modstr["Adds # to # Lightning Damage to Attacks"][0] == modstr["Adds # to # Lightning Damage"][0] == modstr["Adds # to # Lightning Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_lightning_damage_to_attacks"] = [round(modstr["Adds # to # Lightning Damage to Attacks"][0], 2), modstr["Adds # to # Lightning Damage to Attacks"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Lightning Damage to Attacks"][0] = modstr["Adds # to # Lightning Damage"][0] = modstr["Adds # to # Lightning Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_lightning_damage_to_attacks"] = "Adds # to # Lightning Damage to Attacks"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Lightning Damage to Spells"][0] and (modstr["Adds # to # Lightning Damage to Spells"][0] == modstr["Adds # to # Lightning Damage"][0] == modstr["Adds # to # Lightning Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_lightning_damage_to_spells"] = [round(modstr["Adds # to # Lightning Damage to Spells"][0], 2), modstr["Adds # to # Lightning Damage to Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Lightning Damage to Spells"][0] = modstr["Adds # to # Lightning Damage"][0] = modstr["Adds # to # Lightning Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_lightning_damage_to_spells"] = "Adds # to # Lightning Damage to Spells"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Lightning Damage"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_lightning_damage"] = [round(modstr["Adds # to # Lightning Damage"][0], 2), modstr["Adds # to # Lightning Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Lightning Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_lightning_damage"] = "Adds # to # Lightning Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["Adds # to # Fire Damage to Attacks"][0] and (modstr["Adds # to # Fire Damage to Attacks"][0] == modstr["Adds # to # Fire Damage"][0] == modstr["Adds # to # Fire Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_fire_damage_to_attacks"] = [round(modstr["Adds # to # Fire Damage to Attacks"][0], 2), modstr["Adds # to # Fire Damage to Attacks"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Fire Damage to Attacks"][0] = modstr["Adds # to # Fire Damage"][0] = modstr["Adds # to # Fire Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_fire_damage_to_attacks"] = "Adds # to # Fire Damage to Attacks"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Fire Damage to Spells"][0] and (modstr["Adds # to # Fire Damage to Spells"][0] == modstr["Adds # to # Fire Damage"][0] == modstr["Adds # to # Fire Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_fire_damage_to_spells"] = [round(modstr["Adds # to # Fire Damage to Spells"][0], 2), modstr["Adds # to # Fire Damage to Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Fire Damage to Spells"][0] = modstr["Adds # to # Fire Damage"][0] = modstr["Adds # to # Fire Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_fire_damage_to_spells"] = "Adds # to # Fire Damage to Spells"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Fire Damage"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_fire_damage"] = [round(modstr["Adds # to # Fire Damage"][0], 2), modstr["Adds # to # Fire Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Fire Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_fire_damage"] = "Adds # to # Fire Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["Adds # to # Cold Damage to Attacks"][0] and (modstr["Adds # to # Cold Damage to Attacks"][0] == modstr["Adds # to # Cold Damage"][0] == modstr["Adds # to # Cold Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_cold_damage_to_attacks"] = [round(modstr["Adds # to # Cold Damage to Attacks"][0], 2), modstr["Adds # to # Cold Damage to Attacks"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Cold Damage to Attacks"][0] = modstr["Adds # to # Cold Damage"][0] = modstr["Adds # to # Cold Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_cold_damage_to_attacks"] = "Adds # to # Cold Damage to Attacks"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Cold Damage to Spells"][0] and (modstr["Adds # to # Cold Damage to Spells"][0] == modstr["Adds # to # Cold Damage"][0] == modstr["Adds # to # Cold Damage to Spells and Attacks"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_cold_damage_to_spells"] = [round(modstr["Adds # to # Cold Damage to Spells"][0], 2), modstr["Adds # to # Cold Damage to Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Cold Damage to Spells"][0] = modstr["Adds # to # Cold Damage"][0] = modstr["Adds # to # Cold Damage to Spells and Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_cold_damage_to_spells"] = "Adds # to # Cold Damage to Spells"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Cold Damage"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_cold_damage"] = [round(modstr["Adds # to # Cold Damage"][0], 2), modstr["Adds # to # Cold Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Cold Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_cold_damage"] = "Adds # to # Cold Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["Adds # to # Physical Damage to Attacks"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_physical_damage_to_attacks"] = [round(modstr["Adds # to # Physical Damage to Attacks"][0], 2), modstr["Adds # to # Physical Damage to Attacks"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Physical Damage to Attacks"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_physical_damage_to_attacks"] = "Adds # to # Physical Damage to Attacks"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["Adds # to # Physical Damage to Spells"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_adds_physical_damage_to_spells"] = [round(modstr["Adds # to # Physical Damage to Spells"][0], 2), modstr["Adds # to # Physical Damage to Spells"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["Adds # to # Physical Damage to Spells"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_adds_physical_damage_to_spells"] = "Adds # to # Physical Damage to Spells"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Cold Damage"][0] and (modstr["#% increased Cold Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Elemental Damage with Attack Skills"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_cold_damage_with_attack_skills"] = [round(modstr["#% increased Cold Damage"][0], 2), modstr["#% increased Cold Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Cold Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Elemental Damage with Attack Skills"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_cold_damage_with_attack_skills"] = "#% increased Cold Damage with Attack Skills"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Cold Damage"][0] and (modstr["#% increased Cold Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Spell Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_cold_spell_damage"] = [round(modstr["#% increased Cold Damage"][0], 2), modstr["#% increased Cold Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Cold Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Spell Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_cold_spell_damage"] = "#% increased Cold Spell Damage"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Cold Damage"][0] and (modstr["#% increased Cold Damage"][0] == modstr["#% increased Elemental Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_cold_damage"] = [round(modstr["#% increased Cold Damage"][0], 2), modstr["#% increased Cold Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Cold Damage"][0] = modstr["#% increased Elemental Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_cold_damage"] = "#% increased Cold Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Fire Damage"][0] and (modstr["#% increased Fire Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Elemental Damage with Attack Skills"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_fire_damage_with_attack_skills"] = [round(modstr["#% increased Fire Damage"][0], 2), modstr["#% increased Fire Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Fire Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Elemental Damage with Attack Skills"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_fire_damage_with_attack_skills"] = "#% increased Fire Damage with Attack Skills"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Fire Damage"][0] and (modstr["#% increased Fire Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Spell Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_fire_spell_damage"] = [round(modstr["#% increased Fire Damage"][0], 2), modstr["#% increased Fire Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Fire Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Spell Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_fire_spell_damage"] = "#% increased Fire Spell Damage"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Fire Damage"][0] and (modstr["#% increased Fire Damage"][0] == modstr["#% increased Elemental Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_fire_damage"] = [round(modstr["#% increased Fire Damage"][0], 2), modstr["#% increased Fire Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Fire Damage"][0] = modstr["#% increased Elemental Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_fire_damage"] = "#% increased Fire Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Lightning Damage"][0] and (modstr["#% increased Lightning Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Elemental Damage with Attack Skills"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_lightning_damage_with_attack_skills"] = [round(modstr["#% increased Lightning Damage"][0], 2), modstr["#% increased Lightning Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Lightning Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Elemental Damage with Attack Skills"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_lightning_damage_with_attack_skills"] = "#% increased Lightning Damage with Attack Skills"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Lightning Damage"][0] and (modstr["#% increased Lightning Damage"][0] == modstr["#% increased Elemental Damage"][0] == modstr["#% increased Spell Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_lightning_spell_damage"] = [round(modstr["#% increased Lightning Damage"][0], 2), modstr["#% increased Lightning Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Lightning Damage"][0] = modstr["#% increased Elemental Damage"][0] = modstr["#% increased Spell Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_lightning_spell_damage"] = "#% increased Lightning Spell Damage"
	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	elif modstr["#% increased Lightning Damage"][0] and (modstr["#% increased Lightning Damage"][0] == modstr["#% increased Elemental Damage"][0]):
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_lightning_damage"] = [round(modstr["#% increased Lightning Damage"][0], 2), modstr["#% increased Lightning Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Lightning Damage"][0] = modstr["#% increased Elemental Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_lightning_damage"] = "#% increased Lightning Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Global Physical Damage"][0] and base not in ["Caster Weapon", "Wand (Spellslinger)"]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_increased_physical_damage"] = [round(modstr["#% increased Global Physical Damage"][0], 2), modstr["#% increased Global Physical Damage"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Global Physical Damage"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_increased_physical_damage"] = "#% total increased Physical Damage"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["#% increased Attack Speed"][0] and base not in ["Caster Weapon", "Wand (Spellslinger)"]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_total_attack_speed"] = [round(modstr["#% increased Attack Speed"][0], 2), modstr["#% increased Attack Speed"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["#% increased Attack Speed"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_total_attack_speed"] = "+#% total Attack Speed"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["# to Dexterity"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_total_dexterity"] = [round(modstr["# to Dexterity"][0], 2), modstr["# to Dexterity"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["# to Dexterity"][0] = modstr["# to Strength and Dexterity"][0] = modstr["# to Dexterity and Intelligence"][0] = modstr["# to all Attributes"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_total_dexterity"] = "+# total to Dexterity"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["# to Intelligence"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_total_intelligence"] = [round(modstr["# to Intelligence"][0], 2), modstr["# to Intelligence"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["# to Intelligence"][0] = modstr["# to Strength and Intelligence"][0] = modstr["# to Dexterity and Intelligence"][0] = modstr["# to all Attributes"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_total_intelligence"] = "+# total to Intelligence"

	# Check that the value is non-zero and if necessary that it isn't a bad base for that mod and that all values are equal
	if modstr["# to Strength"][0]:
		# Assign the value to our pseudomod
		ret["pseudo.pseudo_total_strength"] = [round(modstr["# to Strength"][0], 2), modstr["# to Strength"][1]]
		# zero out the mods being used by pseudomod.  Don't delete from list so that we don't crash if checked later
		modstr["# to Strength"][0] = modstr["# to Strength and Intelligence"][0] = modstr["# to Strength and Dexterity"][0] = modstr["# to all Attributes"][0] = 0
		# Add mod to reverse lookup in case mod gets trimmed
		reverse["pseudo.pseudo_total_strength"] = "+# total to Strength"

	return ret
